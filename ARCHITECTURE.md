
# Pa11y Sidekick Architecture

Hello! This is Pa11y Sidekick's architecture guide. We're really excited to show you how to get started with contributing.

By the end of this guide, you should feel comfortable with the general architecture of the application. We also maintain sections geared towards people who specialise in different areas of development.

This guide does not cover basic running, testing, or deployment of Pa11y Sidekick. Refer to the [README] for these.


## Table of Contents

  - [Getting Started](#getting-started)
  - [The Basics](#the-basics)
  - [Back End](#back-end)
    - [Entry-Points](#entry-points)
    - [Controllers](#controllers)
    - [Middleware](#middleware)
    - [Logging](#logging)
  - [Front End](#front-end)
    - [View Templates](#view-templates)
      - [Layouts](#layouts)
      - [Partials](#partials)
      - [Default View Data](#default-view-data)
    - [View Helpers](#view-helpers)
    - [Static Files](#static-files)
    - [CSS](#css)
    - [Client-Side JavaScript](#client-side-javascript)
  - [Databases](#databases)
    - [Models](#models)
    - [Migrations](#migrations)
    - [Seeding](#seeding)
  - [Testing](#testing)
    - [Unit Tests](#unit-tests)
    - [Integration Tests](#integration-tests)


## Getting Started

Pa11y Sidekick is a [Node.js] application. You'll need to have a few skills you'll need before understanding/contributing to different parts of the application. We recommend reading these sections after [the basics](#the-basics).

  - **[Back End](#back-end)**:
    Beginner–intermediate [Node.js] knowledge will be required. We make use of [Promises] for the core library and models. A working knowledge of [Express] is helpful but not required.

  - **[Front End](#front-end)**:
    Either HTML/CSS knowledge and/or client-side JavaScript knowledge will be required. We use [Sass] for styling and [Browserify] to bundle our client-side JavaScript; for templating, we use [Dust.js]. An understanding of these is useful but not a prerequisite.

  - **[Databases](#databases)**:
    We use [PostgreSQL] to persist data, and the [Knex.js] client library to communicate with it.

Once you've read up on your preferred areas, you should also review the section on [testing](#testing).


## The Basics

OK, are you ready? This part of the guide covers things that are useful for all developers to know. We'll be covering the general application structure and where to find things.

The directory structure of Pa11y Sidekick can be seen below. We'll cover each of these folders in turn.

```
Sidekick
├── controller
├── data
│   ├── migration
│   └── seed
├── lib
├── middleware
├── model
├── public
├── script
├── test
│   ├── integration
│   └── unit
└── view
    ├── helper
    ├── layout
    ├── partial
    ├── script
    └── style
```

### The `controller` folder

This is where application controllers live. These files mostly handle routing through [Express]. [Read the controllers documentation](#controllers) for more information.

### The `data/migration` folder

This is where database migrations live. Migrations are handled by [Knex.js], and files in this folder are timestamped and generated by a script. [Read the migrations documentation](#migrations) for more information.

### The `data/seed` folder

This is where database seed data lives, seeding is handled by [Knex.js]. [Read the seeding documentation](#seeding) for more information.

### The `lib` folder

The `lib` folder is where the core code can be found – the files in here tie together the whole application. [Read the entry-points documentation](#entry-points) for more information.

### The `middleware` folder

This folder contains [Express] middleware that is used by multiple routes. [Read the middleware documentation](#controllers) for more information.

### The `model` folder

This is where application models live – the only code that should interface with the database. These models make heavy use of [Knex.js], but we don't use an ORM. [Read the models documentation](#models) for more information.

### The `public` folder

The `public` folder is used to serve static assets that don't require any additional back end logic applied, e.g. images. The [Sass] and [Browserify] bundles are also compiled into this folder. [Read the static files documentation](#static-files) for more information.

### The `script` folder

This folder contains Node.js scripts that are used as part of the build process. Most of these aren't interfaced with directly, they're used by [Make].

### The `test/integration` folder

This is where integration tests live. These tests build and run the entire application, and verify that each page is working as expected. [Read the integration tests documentation](#integration-tests) for more information.

### The `test/unit` folder

This folder is where the application's unit tests can be found. These test individual files and make heavy use of mocking. The directory structure in here mimics the main application structure. [Read the unit tests documentation](#unit-tests) for more information.

### The `view` folder

This is where most of the application's front end assets live. [Dust.js] view files are found in here, as well as default view variables. [Read the view templates documentation](#view-templates) for more information.

### The `view/helper` folder

This folder contains [Dust.js helpers and filters][dust helpers], which are JavaScript files. These are used to extend the templating language. [Read the view helpers documentation](#view-helpers) for more information.

### The `view/layout` folder

View layout templates live in here. These contain most of the boilerplate HTML required to render a page and are used by the application's view files. [Read the layouts documentation](#layouts) for more information.

### The `view/partial` folder

This is where view partials live. Partials are used to reduce repetition across the views, and when the same elements are needed on multiple pages. [Read the partials documentation](#partials) for more information.

### The `view/script` folder

This folder is where the client-side JavaScript lives. These files are compiled together with [Browserify] and minified, so you can use `require` in them. [Read the client-side JavaScript documentation](#client-side-javascript) for more information.

### The `view/style` folder

Sass files can be found here. These are compiled and saved as CSS on the fly. [Read the CSS documentation](#css) for more information.


## Back End

Hiya. If you're all caught up on the [application structure](#the-basics) then we can start looking into back end specific stuff in more detail! We'll be learning about the application core, how to create [Express] routes/controllers/middleware, and how to connect the different parts of the application. This section doesn't cover databases, that has [a section of its own](#databases).

### Entry-Points

The best place to start is with [`index.js`](index.js). This is the main entry-point for the application. You'll notice that this file is very light-weight, that's because its only job is to take config values from the environment and pass them into the library code. There are two important files that are required into this one.

The first is [`config.js`](config.js). This exports a config object which is mostly built from environment variables in `process.env`. If we jump back to `index.js` you'll see that the configuration is just passed into the `sidekick` function.

The `sidekick` function comes from [`lib/sidekick.js`](lib/sidekick.js), which is the most important file in the application – it ties everything else together. The file itself is heavily commented, and should have excellent test coverage. If you're interested in making changes to this file, then head on over to it and read through the comments.

### Controllers

Controllers live in the `controller` folder and register multiple routes with [Express]. The controllers are split into files based on the part of the application that they relate to.

Each controller must export a function that accepts a single argument. That argument will be a `dashboard` object, which is created by [`lib/sidekick.js`](lib/sidekick.js). When the application starts, each of these controllers is loaded and called.

A simple controller:

```js
module.exports = dashboard => {

    // This is a reference to the Express application
    const app = dashboard.app;

    // Register a route
    app.get('/my-route', (request, response) => {

        // Render a Dust template. This corresponds to a template
        // file in the `view` folder
        response.render('my-view', {
            // some view data
        });

    });

};
```

Controllers often load and mount [other middleware](#middleware), as well as using [models](#models) to access the database. You should look into the existing controllers for examples of this.

As well as the view data that you pass into the view from your controller, there is also [default view data](#default-view-data) to take into consideration. The view data that you specify will override the defaults if there's a conflict.

### Middleware

Middleware can be used to reduce repetition between [controllers](#controllers), middleware files live in the `middleware` folder. These files don't have a prescribed structure or exports.

### Logging

For logging, we use [winston] and [morgan]. Winston is set up outside of the main application files in [`config.js`](config.js), this allows us to inject a mock/silent logger in the [integration tests](#integration-tests).

Morgan is used to log requests, and this is mounted as an Express middleware. We actually stream morgan's request logs into winston under the `verbose` level. This allows users to easily ignore them by tweaking their preferred log level.


## Front End

OK, so you want to know how to work on Pa11y Sidekick's front end? Let's do it! This section will explain how to add templates (with [Dust.js]), CSS (with [Sass]), and client-side JavaScript (with [Browserify]).

### View Templates

View templates live in the `view` folder, and are written in the [Dust.js] templating language. We make use of [blocks and inline partials][dust-blocks] for template inheritance, and try to split repeated code into partials. Here's an example view:

```html
<!-- Extend the default layout -->
{>"layout/default"/}

<!-- insert the following into the layout title block -->
{< title}
    My Page
{/title}

<!-- insert the following into the layout content block -->
{< content}

    <h1>Hello World!</h1>

    <p>This is data from the controller: {example}</p>

{/content}
```

In order to see your view rendered in-browser, a controller will have to reference it. [Take a look at the controller documentation](#controllers) for more information on how to do this.

The `error.dust` view is a special one – it's used to render errors that get caught by the application.

#### Layouts

As mentioned above, we use [blocks and inline partials][dust-blocks] for template inheritance. This allows for multiple modifiable blocks in our layouts which each view can add data to.

The [default layout](view/layout/default.dust) is used by most views; it provides boilerplate HTML and loads in the required scripts and styles.

#### Partials

Partials are used to reduce repetition in view files, and common markup patterns should be moved into partials. The best way to get aquainted with how we use partials is to [look through the folder](view/partial).

#### Default View Data

Controllers are normally in charge of passing data to the view, and a controller is required for both rendering the views and interfacing between them and the database. For data that's static and unchanging, you can use [`view/defaults.json`](view/defaults.json) – This file is loaded into every view.

So if the default view data file contains this:

```json
{
    "thing": "World"
}
```

Then this view will render "Hello World!":

```html
Hello {thing}!
```

### View Helpers

View helpers are used to extend the templating language, and to ensure that your views themselves don't have as much logic in them. You should avoid writing these unless absolutely necessary – try to get the data into the format you need in the controller first.

These files live in the `view/helper` folder; they should be JavaScript files that export a function which accepts a [Dust.js] instance as an argument:

```js
module.exports = dust => {
    dust.helpers.currentYear = chunk => {
        const year = (new Date()).getFullYear();
        return chunk.write(year);
    };
};
```

Read the [Dust.js helpers and filters][dust helpers] documentation for more information, or take a look at some of [the existing helpers](view/helper).

### Static Files

All files in the `public` folder are served by an Express static middleware. This is where you should put images and assets that need no back end processing.

This is also the location where CSS and JavaScript bundles are saved in production mode.

### CSS

[Sass] styles live in the `view/style` folder, and they are compiled on the fly in development mode. In production mode, they're compiled once and saved to the `public` folder.

Because it's Sass, you can use `@import` statements and split your styles across multiple files. This is helpful when it comes to organisation.

Pa11y Sidekick uses [Resave Sass][resave-sass] to do this.

### Client-Side JavaScript

Client-side JavaScript lives in the `view/script` folder, and it is compiled on the fly in development mode. In production mode, it's compiled once and saved to the `public` folder.

Because we use [Browserify], you can use `require` calls and split your JavaScript across multiple files. This is helpful when it comes to organisation. You can also load in modules that have been installed via npm.

Pa11y Sidekick uses [Resave Browserify][resave-browserify] to do this.


## Databases

Hello! This section will teach you how to manage Pa11y Sidekick's database. We'll be covering models, migrations, and seeding. We use [PostgreSQL] to persist data with [Knex.js] as a client library. We use [shortid] to create url-friendly unique identifiers.

### Models

Models live in the `model` folder and are used to access the database with [Knex.js]. Each model file represents a single table in the database, and consistency between models is encouraged.

Each model must export a function that accepts a single argument. That argument will be a `dashboard` object, which is created by [`lib/sidekick.js`](lib/sidekick.js). The model function must also return an object. When the application starts, each of these models is loaded and called.

A simple model:

```js
module.exports = dashboard => {

    // This is a reference to the Knex.js database instance
    const database = dashboard.database;

    // It's a good idea to store the table name in a variable
    // to reduce repetition when the model has multiple methods
    const table = 'sites';

    // Define the model as a plain object
    const model = {

        // Define methods on the model. These should normally
        // return promises
        getAll() {
            return database.select('*').from(table);
        }

    };

    // Return the model (this is important)
    return model;
};
```

The returned model object is added to the `dashboard` object automatically. This makes accessing models in controllers and other parts of the application much easier. So if we define a model in `model/example.js`, then this will be available in controllers as `dashboard.model.example`.

### Migrations

Migrations are created by using a script, you should never create these files manually. Run the following to create a new migration file:

```sh
./script/create-migration.js <migration-name>
```

The migration name should be descriptive of the changes you're making. Once you've created the migration file, it's worth copying the contents of an existing one so that the code style is the same. You should read the [Knex.js documentation on migrations][knex-migrations] for more information on the structure of these files.

Migrations can be run or rolled back using the following make targets (which correspond to files in the `script` folder):

```sh
make db-migrate-up
make db-migrate-down
```

### Seeding

Seed files live in `data/seed`, and are loaded into a database through either a Make target or automatically when [integration tests](#integration-tests) are run. It's useful to copy an existing seed file when adding new test data, also be aware that modifications to existing seed files may cause issues with the tests.

We split seed data into folders depending on their purpose. For example, `data/seed/demo` is the seed data used to demonstrate Sidekick, while `data/seed/test/base` is used in the integration tests.

For more information on the structure of these files, read the [Knex.js documentation on seeding][knex-seeding].

```sh
make db-seed
```


## Testing

Automated testing is an important part of working on Pa11y Sidekick, let's dig into how we do it!

### Unit Tests

Unit tests live in the `test/unit` folder, where the directory structure mimics the main structure.

Not all of the codebase is unit tested, we find that trying to unit test models and controllers doesn't really give us much benefit over just integration tests. The code that's extremely important to test is anything in the `lib` folder. We try to maintain 100% coverage of the core code, and we also write tests for middleware currently.

For testing we use:

  - [Mocha] as a test framework
  - [Proclaim] as an assertion library
  - [Sinon] and [Mockery] for mocks and spies

Dig into the [`test/unit`](test/unit) folder to get an idea of what our tests look like.

### Integration Tests

We try to maintain integration tests for all of Pa11y Sidekick's features. This means that we can feel confident that our changes haven't broken existing functionality, and that our changes won't be accidentally broken by a later commit.

The integration tests spin up the application in test mode and run the full stack from database to front end. We use the following tools:

  - [Mocha] as a test framework
  - [SuperTest] as an HTTP client and assertion library
  - [Sinon] and [Mockery] for mocks and spies

Dig into the [`test/integration`](test/integration) folder to get an idea of what our tests look like.



[browserify]: http://browserify.org/
[dust-blocks]: http://www.dustjs.com/guides/blocks/
[dust-helpers]: http://www.dustjs.com/docs/helper-api/
[dust.js]: http://www.dustjs.com/
[express]: http://expressjs.com/
[knex-migrations]: http://knexjs.org/#Migrations
[knex-seeding]: http://knexjs.org/#Seeds-API
[knex.js]: http://knexjs.org/
[make]: https://www.gnu.org/software/make/
[mocha]: https://mochajs.org/
[mockery]: https://github.com/mfncooper/mockery
[morgan]: https://github.com/expressjs/morgan
[node.js]: https://nodejs.org/
[postgresql]: http://www.postgresql.org/
[proclaim]: https://github.com/rowanmanning/proclaim
[promises]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
[readme]: README.md
[resave-browserify]: https://github.com/rowanmanning/resave-browserify
[resave-sass]: https://github.com/rowanmanning/resave-sass
[sass]: http://sass-lang.com/
[shortid]: https://github.com/dylang/shortid
[sinon]: http://sinonjs.org/
[supertest]: https://github.com/visionmedia/supertest
[winston]: https://github.com/winstonjs/winston
